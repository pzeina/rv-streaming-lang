"""
This type stub file was generated by pyright.
"""

import threading
import time
from abc import ABC, abstractmethod
from collections import deque
from collections.abc import Callable, Hashable, Iterable, Iterator
from enum import Enum
from typing import Any, Self, TypeVar, TypedDict, overload
from frozendict import frozendict
from readerwriterlock import rwlock
from typing_extensions import override
from logicsponge.core.datastructures import SharedQueue, SharedQueueView

"""Contains the basic types of logicsponge-core (data items, data streams, terms, etc.)."""
logger = ...
class Control(Enum):
    """The possible control signals for DataItems.

    Attributes:
        EOS: The DataItem terminates the DataStream (End Of Stream).

    """
    EOS = ...


State = dict[str, Any]
class LatencyQueue:
    """A queue of latencies, used to generate statistics of terms.

    Attributes:
        queue (deque): The queue of latencies.
        tic_time (float, optional): time of last tic() execution.

    """
    queue: deque
    tic_time: float | None
    def __init__(self, max_size: int = ...) -> None:
        """Create a LatencyQueue object.

        Args:
            max_size (int): the maximal size of the queue. Adding to a queue of this size, leads to
                the removal of the oldest entry.

        """
        ...
    
    def tic(self) -> None:
        """Start a latency measurement.

        To be used with a successive toc().
        """
        ...
    
    def toc(self) -> None:
        """Stop a latency measurement.

        Call after a corresponding tic().
        """
        ...
    
    @property
    def avg(self) -> float:
        """Average latency in seconds.

        Returns:
            float: The average of all latencies in the queue. In [s].

        """
        ...
    
    @property
    def max(self) -> float:
        """Maximum latency in seconds.

        Returns:
            float: The maximum of all latencies in the queue. In [s].

        """
        ...
    


class DataItem:
    """Encapsulates a collection of key/value data pairs, together with associated metadata.

    Contains methods to keep track of timing and control data. The implementation is thread-safe.
    """
    _data: frozendict[str, Any]
    _lock: rwlock.RWLockFair
    _time: float
    _control: set[Control]
    def __init__(self, data: dict[str, Any] | Self | None = ...) -> None:
        """Initialize a new DataItem.

        Args:
            data: Contains the data carried by the DataItem.
                If data is a dict, it copies the key/value data pairs out of the given dict.
                If data is a DataItem, it copies the key/value data pairs out of the given DataItem.
                If data is None, then the DataItem has no key/value data pairs.

        """
        ...
    
    @property
    def has_control_signal(self) -> bool:
        """True iff the DataItem has a control signal."""
        ...
    
    def get_control_signal(self, control: Control) -> bool:
        """Check if a given control signal is set in the data item.

        Args:
            control: The control signal to be checked.

        Returns:
            True if the given control signal is set.

        """
        ...
    
    def set_control_signal(self, control: Control | set[Control]) -> Self:
        """Set the given control signal(s) in the DataItem.

        Args:
            control: The control signal(s).
                If control is a single Control, sets the signal in the DataItem.
                If control is a set of Control, sets all the set's signals in the DataItem.

        Returns:
            The DataItem after setting the control signal(s).

        """
        ...
    
    @property
    def time(self) -> float:
        """The DataItem's time metadata.

        Returns:
            The DataItem's time as a Unix timestamp.

        """
        ...
    
    @time.setter
    def time(self, timestamp: float) -> None:
        ...
    
    def set_time_to_now(self) -> Self:
        """Set the time metadata of the DataItem to the current time.

        Returns:
            The DataITem after setting the time.

        """
        ...
    
    def copy(self) -> DataItem:
        """Copy the current DataItem with the current time as metadata.

        Returns:
            The copied DataItem.

        """
        ...
    
    def __str__(self) -> str:
        """Construct a string description of the DataItem.

        Returns:
            A string of the format "DataItem(dict)" where dict contains all key/value data pairs.

        """
        ...
    
    def __getitem__(self, key: str) -> Any:
        """Return the data value for a given key.

        Args:
            key: The key of the data value to be returned.

        Returns:
            The data value.

        Raises:
            IndexError: If no data value exists for the given key.

        """
        ...
    
    def __delitem__(self, key: str) -> None:
        """Delete the data value for a given key.

        Args:
            key: The key of the data value to be deleted.

        """
        ...
    
    def __contains__(self, key: str) -> bool:
        """Check whether a data value for the given key exists in the DataItem.

        Args:
            key: The key to be checked.

        Returns:
            True if the DataItem contains a data value for the given key.

        """
        ...
    
    def __iter__(self) -> Iterator:
        """Construct an Iterator for the key/value data pairs.

        Returns:
            The iterator.

        """
        ...
    
    def __len__(self) -> int:
        """Compute the number of data values in the DataItem.

        Returns:
            The number of key/value data pairs in the DataItem.

        """
        ...
    
    def __eq__(self, other: object) -> bool:
        """Check whether two DataItems have the same key/value data pairs.

        Args:
            other: The object to compare to.

        Returns:
            True if other is a DataItem and they contain the same key/value data pairs.
            False if other is a DataItem and they do not contain the same key/value data pairs.
            NotImplemented otherwise.

        """
        ...
    
    def __hash__(self) -> int:
        """Compute the hash of the DataItem.

        Returns:
            The hash of the DataItem. Only takes into account key/value data pairs, not the metadata.

        """
        ...
    
    def items(self) -> Iterator[tuple[str, Any]]:
        """Construct an iterator for the key/value data pairs of the DataItem.

        Returns:
            The iterator.

        """
        ...
    
    def keys(self) -> Iterator[str]:
        """Construct an iterator for the keys of the DataItem.

        Returns:
            The iterator.

        """
        ...
    
    def values(self) -> Iterator[Any]:
        """Construct an iterator for the data values of the DataItem.

        Returns:
            The iterator.

        """
        ...
    
    def get(self, key: str, default: Any = ...) -> Any:
        """Get the data value for the given key, or the default value if it doesn't exist.

        Args:
            key: The key of the requested data value.
            default: The default value to be returned if the data value doesn't exist.

        Returns:
            The data value for the key if it exists, default otherwise.

        """
        ...
    


class ViewStatistics(TypedDict):
    """Represents the read/write statistics of a DataStreamView.

    Attributes:
        read: The number of read operations.
        write: The number of read operations.

    """
    read: int
    write: int
    ...


class HistoryBound(ABC):
    """Represents a bound on the DataStream history before which DataItems may be dropped."""
    @abstractmethod
    def items_to_drop(self, ds: DataStream) -> int:
        """Calculate a bound on the DataStream history before which DataItems may be dropped.

        Is not allowed to call DataStream.clean_history.

        Args:
            ds: stream to be considered

        Returns:
            int: The length of the prefix of the history that can be deleted.

        """
        ...
    


class NoneBound(HistoryBound):
    """Marks no DataItems for deletion."""
    @override
    def items_to_drop(self, ds: DataStream) -> int:
        """Calculate a bound on the DataStream history before which DataItems may be dropped.

        Args:
            ds: stream to be considered

        Returns:
            int: Always 0 (don't drop any items).

        """
        ...
    


class NumberBound(HistoryBound):
    """Marks all but the n newest DataItems for deletion."""
    _n: int
    def __init__(self, n: int) -> None:
        """Construct a new NumberBound with a given value of n.

        Args:
            n: The length of the history to keep.

        """
        ...
    
    @override
    def items_to_drop(self, ds: DataStream) -> int:
        """Calculate a bound on the DataStream history before which DataItems may be dropped.

        Args:
            ds: stream to be considered

        Returns:
            int: The number of items to drop, i.e., max(0, len - n) where len is the length of the DataStream.

        """
        ...
    


class DataStream:
    """Represents a data stream, i.e., a sequence of DataItem, with associated metadata.

    The implementation is thread-safe.
    """
    _id: str | None
    _owner: Term
    _data: SharedQueue[DataItem]
    _lock: rwlock.RWLockFair
    _history_bound: HistoryBound
    _history_lock: threading.Lock
    _new_data_callbacks: list[Callable[[DataItem], None]]
    def __init__(self, owner: Term) -> None:
        """Initialize an empty DataStream.

        Args:
            owner: The Term that owns the DataStream. Usually the Term whose output stream we're initializing.
                Potentially used for persistence features.

        """
        ...
    
    def get_id(self) -> str | None:
        """Get ID of the DataStream.

        Returns:
            The stream's ID or None if not set.

        """
        ...
    
    def __len__(self) -> int:
        """Calculate the length of the DataStream, i.e., the number of DataItems.

        Returns:
            The number of DataItems in the DataStream.

        """
        ...
    
    @overload
    def __getitem__(self, index: int) -> DataItem:
        ...
    
    @overload
    def __getitem__(self, index: slice) -> list[DataItem]:
        ...
    
    def __getitem__(self, index: int | slice) -> DataItem | list[DataItem]:
        """Get DataItem(s) with a given index or slice.

        Args:
            index: The item(s) index or slice.

        Returns:
            The requested item(s). A single DataItem if index is an int. A list of DataItems if index is a slice.

        Raises:
            IndexError: If index is invalid.

        """
        ...
    
    def __str__(self) -> str:
        """Construct a string description of the DataStream.

        Returns:
            A string of the format "DataStream(id={id}): [{data_items}]" where {id} is the DataStream's ID
                and {data_items} are the DataItems.

        """
        ...
    
    def append(self, di: DataItem) -> Self:
        """Append a data item to the end of the DataStream.

        Args:
            di: The DataItem to append.

        Returns:
            The DataStream after appending the DataItem.

        """
        ...
    
    def set_history_bound(self, history_bound: HistoryBound) -> Self:
        """Set the history bounds of the DataStream.

        Args:
            history_bound: The HistoryBound to be set.

        Returns:
            The DataStream after setting the history bound.

        """
        ...
    
    def clean_history(self) -> Self:
        """Drop DataItems according to the current history bound.

        If another call to clean_history or a call to append is currently running, returns without modification.

        Returns:
            The DataStream after dropping the DataItems.

        """
        ...
    
    def to_list(self) -> list[DataItem]:
        """Construct a list of all DataItems of the DataStream.

        Returns:
            The list of DataItems.

        """
        ...
    
    def len_until_first_cursor(self) -> int:
        """Calculate the length of the DataStream until the first cursor position of a associated SharedQueueView.

        Returns:
            The length until the first cursor.

        """
        ...
    
    def register_new_data_callback(self, callback: Callable[[DataItem], None]) -> None:
        """Register a "new data" callback function for the DataStream.

        Args:
            callback: the callback function. Is called whenever a new DataItem is appended to the DataStream

        """
        ...
    


class DataStreamView:
    """Represents a view into a data stream, i.e., a prefix of the DataStream, with associated metadata.

    The implementation is thread-safe.
    """
    _id: str | None
    _owner: Term
    _ds: DataStream
    _view: SharedQueueView
    _lock: rwlock.RWLockFair
    def __init__(self, ds: DataStream, owner: Term) -> None:
        """Initialize a new DataStreamView.

        Args:
            ds: The DataStream to which
            owner: The Term that owns the DataStream. Usually the Term whose output stream we're initializing.
                Potentially used for persistence features.

        """
        ...
    
    def get_id(self) -> str | None:
        """Get ID of the DataStreamView.

        Returns:
            The view's ID or None if not set.

        """
        ...
    
    def __len__(self) -> int:
        """Calculate the length of the DataStreamView, i.e., the number of DataItems until its cursor.

        Returns:
            The number of DataItems in the underlying DataStream until the DataStreamView's cursor.

        """
        ...
    
    @overload
    def __getitem__(self, index: int) -> DataItem:
        ...
    
    @overload
    def __getitem__(self, index: slice) -> list[DataItem]:
        ...
    
    def __getitem__(self, index: int | slice) -> DataItem | list[DataItem]:
        """Get DataItem(s) with a given index or slice.

        Args:
            index: The item(s) index or slice.

        Returns:
            The requested item(s). A single DataItem if index is an int. A list of DataItems if index is a slice.

        Raises:
            IndexError: If index is invalid.

        """
        ...
    
    def __str__(self) -> str:
        """Construct a string description of the DataStreamView.

        Returns:
            A string of the format "DataStreamView(id={id}): [{data_items}]" where {id} is the DataStreamView's ID
                and {data_items} are the DataItems.

        """
        ...
    
    def peek(self) -> bool:
        """Check whether a new DataItem is ready.

        Returns:
            True iff a new DataItem is ready (i.e., a call to next will not block)

        """
        ...
    
    def next(self) -> None:
        """Advance the DataStreamView's cursor by one DataItem.

        Blocks if no item is available.

        """
        ...
    
    def tail(self, n: int) -> list[DataItem]:
        """Return the tail."""
        ...
    
    @property
    def stats(self) -> ViewStatistics:
        """Return statistics."""
        ...
    


class Term(ABC):
    """The basic Term class.

    Attributes:
        name (str): The name of the Term. This will also be the name
            of the output stream.
        id (str, optional): Unique id of the Term, or None.

    """
    name: str
    id: str | None
    _outputs: dict[str, DataStream]
    _parent: Term | None
    def __init__(self, name: str | None = ..., **kwargs) -> None:
        """Create a Term."""
        ...
    
    def __mul__(self, other: Term) -> SequentialTerm:
        """Compose the Term sequentially with the other Term."""
        ...
    
    def __or__(self, other: Term | Iterable) -> Self | ParallelTerm:
        """Compose the Term in parallel with the other Term."""
        ...
    
    @abstractmethod
    def start(self, *, persistent: bool = ...) -> None:
        """Start execution of the term."""
        ...
    
    @abstractmethod
    def stop(self) -> None:
        """Signal a Term to stop its execution."""
        ...
    
    @abstractmethod
    def join(self) -> None:
        """Wait for a Term to terminate."""
        ...
    
    def cancel(self) -> None:
        """Cancel the Term."""
        ...
    
    def __str__(self) -> str:
        """Return a str representation."""
        ...
    


class SourceTerm(Term):
    """Term that acts as a source."""
    _thread: threading.Thread | None
    _output: DataStream
    _stop_event: threading.Event
    state: State
    def __init__(self, *args, **kwargs) -> None:
        """Create a SourceTerm object."""
        ...
    
    def run(self) -> None:
        """Overwrite this function to produce the source's output."""
        ...
    
    def enter(self) -> None:
        """Overwrite this function to initialize the source term's thread."""
        ...
    
    def exit(self) -> None:
        """Overwrite this function to clean up the source term's thread."""
        ...
    
    def start(self, *, persistent: bool = ...) -> None:
        """Start the source term's thread."""
        ...
    
    def stop(self) -> None:
        """Stop the Source."""
        ...
    
    def join(self) -> None:
        """Wait for the source thread to terminate."""
        ...
    
    def output(self, data: DataItem) -> None:
        """Output data."""
        ...
    
    def eos(self) -> None:
        """Signal an EOS (end of stream) for this source."""
        ...
    
    @property
    def stats(self) -> dict:
        """Return the source's statistics."""
        ...
    


class ConstantSourceTerm(SourceTerm):
    """Source term with pre-programmed list of data items."""
    _items: list[DataItem]
    def __init__(self, items: list[DataItem], *args, **kwargs) -> None:
        """Create a ConstantSourceTerm object.

        Args:
            items (list[DataItem]): List of data items to output.
            *args: Additional args.
            **kwargs: Additional kwargs.

        """
        ...
    
    def run(self) -> None:
        """Output all items in the list and then terminate."""
        ...
    


class FunctionTerm(Term):
    """A Term that receives data, performs a function on it, and outputs the resulting data.

    Attributes:
        state (State): The Term's state. Any state should go in here.

    """
    _inputs: dict[str, DataStreamView]
    _output: DataStream
    _thread: threading.Thread | None
    _stop_event: threading.Event
    _latency_queue: LatencyQueue
    state: State
    def __init__(self, *args, **kwargs) -> None:
        """Create a FunctionTerm object."""
        ...
    
    def eos(self) -> None:
        """Signal an EOS (end of stream) for the function term."""
        ...
    
    def f(self, *args, **kwargs):
        """Execute f on reception of a new DataItem."""
        ...
    
    def run(self, *args, **kwargs) -> None:
        """Execute run and terminate afterwards."""
        ...
    
    def stop(self) -> None:
        """Stop the Term."""
        ...
    
    def join(self) -> None:
        """Wait until the Term terminates."""
        ...
    
    def enter(self) -> None:
        """Overwrite this function to initialize the function term's thread."""
        ...
    
    def exit(self) -> None:
        """Overwrite this function to clean up the function term's thread."""
        ...
    
    def start(self, *, persistent: bool = ...) -> None:
        """Start the function term's thread."""
        ...
    
    def next(self, input_stream: DataStreamView) -> None:
        """Wait for next data on input stream."""
        ...
    
    def output(self, data: DataItem | None) -> None:
        """Append data to the output stream if data is not None."""
        ...
    
    @property
    def stats(self) -> dict:
        """Return statistics.

        TODO: fix read/write statistics.
        """
        ...
    


class DynamicSpawnTerm(Term):
    """Spawns new terms for each unique filter_key. Dispatches the inputs and merges the outputs."""
    _filter_key: str
    _spawn_fun: Callable[[Hashable], Term]
    _spawned_streams: dict[Hashable, DataStream]
    _spawned_terms: dict[Hashable, Term]
    _thread: threading.Thread | None
    _output: DataStream
    _outputs: dict[str, DataStream]
    def __init__(self, filter_key: str, spawn_fun: Callable[[Hashable], Term], *args, **kwargs) -> None:
        """Create a DynamicSpawnTerm object."""
        ...
    
    def start(self, *, persistent: bool = ...) -> None:
        """Start the Term."""
        ...
    
    def run(self, ds: DataStreamView) -> None:
        """Execute run."""
        ...
    
    def eos(self) -> None:
        """Signal an EOS (end of stream) for the term."""
        ...
    
    def enter(self) -> None:
        """Overwrite this function to initialize the term's thread."""
        ...
    
    def exit(self) -> None:
        """Overwrite this function to clean up the term's thread."""
        ...
    
    def stop(self) -> None:
        """Stop the Term."""
        ...
    
    def join(self) -> None:
        """Wait for the Term to terminate."""
        ...
    
    @property
    def stats(self) -> dict:
        """Return the statistics.

        TODO: fix read/write statistics.
        """
        ...
    


class CompositeTerm(Term):
    """A Term that is composed of other Terms."""
    term_left: Term
    term_right: Term
    def __init__(self, term_left: Term, term_right: Term) -> None:
        """Create a CompositeTerm object."""
        ...
    
    def start(self, *, persistent: bool = ...) -> None:
        """Start the Term."""
        ...
    
    def stop(self) -> None:
        """Stop the Term."""
        ...
    
    def join(self) -> None:
        """Wait until the Term terminates."""
        ...
    


class ParallelTerm(CompositeTerm):
    """Parallel composition of Terms."""
    def __init__(self, *args, **kwargs) -> None:
        """Create a ParallelTerm object."""
        ...
    
    def __str__(self) -> str:
        """Return as string."""
        ...
    


class SequentialTerm(CompositeTerm):
    """Sequential composition of Terms."""
    def __init__(self, *args, **kwargs) -> None:
        """Create a SequentialTerm object."""
        ...
    
    def __str__(self) -> str:
        """Return as string."""
        ...
    


class Stop(Term):
    """Stops a data stream. It produces an empty output stream."""
    def start(self, *, persistent: bool = ...) -> None:
        """Start the Term."""
        ...
    
    def stop(self) -> None:
        """Stop the Term."""
        ...
    
    def join(self) -> None:
        """Wait until Term terminates."""
        ...
    


class Flatten(FunctionTerm):
    """Flattens the first data steam. The level of flattening can be specified."""
    level: int | None
    def __init__(self, *args, level: int | None = ..., **kwargs) -> None:
        """Create a Flatten object."""
        ...
    
    def f(self, items: dict[str, DataItem]) -> DataItem:
        """Execute f on new data."""
        ...
    


class MergeToSingleStream(FunctionTerm):
    """Merges multiple streams into a single stream."""
    def __init__(self, *args, combine: bool = ..., **kwargs) -> None:
        """Create a MergeToSingleStream object."""
        ...
    
    def f(self, items: dict[str, DataItem]) -> DataItem:
        """Execute the Term's f."""
        ...
    


class Linearizer(FunctionTerm):
    """Linearize into a single stream."""
    _info: bool
    _lock: rwlock.RWLockFair
    _new_data: threading.Condition
    def __init__(self, *args, info: bool = ..., **kwargs) -> None:
        """Create a Linearizer object."""
        ...
    
    def run(self, dsvs: dict[str, DataStreamView]) -> None:
        """Execute on run."""
        ...
    


class KeyValueFilter(FunctionTerm):
    """Applies a key-value filter."""
    key_value_filter: Callable[[str, Any], bool] | None
    def __init__(self, *args, key_value_filter: Callable[[str, Any], bool] | None = ..., **kwargs) -> None:
        """Create a new KeyValueFilter.

        Args:
            key_value_filter (Callable[[str, Any], bool], optional): Filter to be applied to
            each key-value pair in data item.

            args: Additional args.
            kwargs: Additional kwargs.

        """
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Run the f."""
        ...
    


class DataItemFilter(FunctionTerm):
    """Filters data items based on keys or not_keys."""
    data_item_filter: Callable[[DataItem], bool] | None
    def __init__(self, *args, data_item_filter: Callable[[DataItem], bool] | None = ..., **kwargs) -> None:
        """Create a new DataItemFilter.

        key_value_filter: Callable[[DataItem], bool]
        Filter to be applied to each key-value pair in data item.
        """
        ...
    
    def f(self, item: DataItem) -> DataItem | None:
        """Execute on new data."""
        ...
    


class KeyFilter(KeyValueFilter):
    """Filters data items based on keys or not_keys."""
    keys: None | str | list[str]
    not_keys: None | str | list[str]
    def __init__(self, *args, keys: None | str | list[str] = ..., not_keys: None | str | list[str] = ..., **kwargs) -> None:
        """Create a new KeyFilter.

        keys: None, str, or list of str, optional
            Keys to include in the calculation.
        not_keys: None, str, or list of str, optional
            Keys to exclude from the calculation. Requires keyword argument.
        """
        ...
    


class Print(FunctionTerm):
    """Prints selected keys of item, but outputs original item."""
    keys: None | str | list[str]
    not_keys: None | str | list[str]
    print_fun: Callable
    def __init__(self, *args, keys: None | str | list[str] = ..., print_fun: Callable = ..., **kwargs) -> None:
        """Create a Print object."""
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Execute the Term's f."""
        ...
    


class PPrint(Print):
    """Like Print, with using pprint.pprint."""
    def __init__(self, *args, keys: None | str | list[str] = ..., print_fun: Callable = ..., **kwargs) -> None:
        """Create a PPrint object."""
        ...
    


class PrintKeys(FunctionTerm):
    """Prints the keys in a data item. Outputs the original item."""
    print_fun: Callable
    def __init__(self, *args, print_fun: Callable = ..., **kwargs) -> None:
        """Create a PrintKeys object."""
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Run the Term's f."""
        ...
    


class Dump(FunctionTerm):
    """Print the whole DataStream at every new item."""
    print_fun: Callable
    def __init__(self, *args, print_fun: Callable = ..., **kwargs) -> None:
        """Create a Dump object."""
        ...
    
    def f(self, di: DataItem) -> None:
        """Run the Term's f."""
        ...
    


class Rename(FunctionTerm):
    """Renames keys."""
    fun: Callable[[str], str]
    def __init__(self, *args, fun: Callable[[str], str] | dict[str, str] = ..., **kwargs) -> None:
        """Create a Rename object."""
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Run the Term's f."""
        ...
    


class Id(FunctionTerm):
    """Identity. Id only forwards the 1st stream."""
    def __init__(self, *args, **kwargs) -> None:
        """Create an Id object."""
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Forward data."""
        ...
    


class EosFilter(Id):
    """Removes all EOS data items from the data stream.

    Will stop at reception of EOS, but will not send one itself.
    This is almost always undesired behavior; use with caution.
    """
    def __init__(self, *args, **kwargs) -> None:
        """Create an EosFilter object."""
        ...
    
    def eos(self) -> None:
        """Run in case of eos in stream."""
        ...
    


class AddIndex(FunctionTerm):
    """Add an index key."""
    key: str
    index: int
    def __init__(self, *args, key: str, index: int = ..., **kwargs) -> None:
        """Create an AddIndex object."""
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Execute the Term's f."""
        ...
    


class Delay(FunctionTerm):
    """Delays a data stream."""
    delay_s: float
    def __init__(self, *args, delay_s: float, **kwargs) -> None:
        """Create an instance.

        Args:
            delay_s (float): The delay in seconds.
            args: Additional args.
            kwargs: Additional kwargs.

        """
        ...
    
    def f(self, item: DataItem) -> DataItem:
        """Run the Term's f."""
        ...
    


KT = TypeVar("KT")
VT = TypeVar("VT")
def merge_dicts(outputs1: dict[KT, VT], outputs2: dict[KT, VT]) -> dict[KT, VT]:
    """Merge two dicts and return the merged one."""
    ...

def was_overwritten(f: Callable) -> bool:
    """Return if the argument was overwritten."""
    ...

def get_annotations(obj: object, method_name: str) -> list | None:
    """Return the annotations of a method in an object."""
    ...

def parallel(li: list[Term]) -> Term:
    """Create a ParallelTerm for the arguments."""
    ...

def flatten_dict(d: dict[str, Any] | DataItem, parent_key: str | None = ..., sep: str = ...) -> dict[str, Any]:
    """Return a flattened dict."""
    ...

def has_callable_signature(func: Any, args: tuple, ret: Any) -> bool:
    """Return if a func is callable."""
    ...

