"""
This type stub file was generated by pyright.
"""

from threading import Condition
from typing import Generic, NewType, TypeVar
from readerwriterlock import rwlock

"""Contains data structures for internal use in logicsponge-core."""
T = TypeVar("T")
CursorID = NewType("CursorID", int)
class SharedQueueNode(Generic[T]):
    """Node in the SharedQueue."""
    value: T
    next: SharedQueueNode | None
    prev: SharedQueueNode | None
    def __init__(self, value: T) -> None:
        """Create a SharedQueueNode object."""
        ...
    


class SharedQueue(Generic[T]):
    """SharedQueue."""
    _head: SharedQueueNode[T] | None
    _tail: SharedQueueNode[T] | None
    _global_lock: rwlock.RWLockFair
    _new_data: Condition
    _next_cid: int
    _cursors: dict[CursorID, SharedQueueNode[T] | None]
    def __init__(self) -> None:
        """Create a SharedQueue object."""
        ...
    
    def register_cursor(self) -> CursorID:
        """Register a new cursor.

        A cursor can point to a specific node in the queue. It can be advanced via next.

        Returns:
            the ID of the newly created cursor

        """
        ...
    
    def unregister_cursor(self, cid: CursorID) -> None:
        """Unregister a cursor.

        Args:
            cid: the ID of the cursor

        """
        ...
    
    def create_view(self) -> SharedQueueView[T]:
        """Create a new SharedQueueView into the SharedQueue.

        Returns:
            the new SharedQueueView

        """
        ...
    
    def __len__(self) -> int:
        """Return the length of the queue.

        Returns:
            the number of elements in the queue

        """
        ...
    
    def len_until_cursor(self, cid: CursorID) -> int:
        """Return the length of the queue until a given cursor.

        Args:
            cid: the cursor ID until which the length is computed

        Returns:
            the number of elements in the queue until the cursor's node

        """
        ...
    
    def len_until_first_cursor(self) -> int:
        """Return the length until the least advanced cursor.

        Returns:
            the number of elements in the queue until the first cursor

        """
        ...
    
    def __getitem__(self, index: int | slice) -> T | list[T]:
        """Get items from the queue.

        Args:
            index: the index of the item to be returned, or the slice of the items to be returned

        Returns:
            the item at the index, or the list of items of the slice

        Raises:
            IndexError: if index is invalid in the queue
            TypeError: if index is neither int nor slice

        """
        ...
    
    def get_relative(self, cid: CursorID, index: int) -> T:
        """Get items from the queue relative to a cursor.

        Args:
            cid: the ID of the cursor
            index: the relative index of the item to be returned

        Returns:
            the item at the relative index

        Raises:
            IndexError: if index is invalid in the queue

        """
        ...
    
    def to_list(self) -> list[T]:
        """Return the elements of the queue as a list.

        Returns:
             the list of elements

        """
        ...
    
    def to_list_until_cursor(self, cid: CursorID) -> list[T]:
        """Return the elements of the queue until a given cursor as a list.

        Args:
            cid: the ID of the cursor

        Returns:
             the list of elements

        """
        ...
    
    def append(self, value: T) -> None:
        """Append to the end of the queue.

        Args:
            value: the value to be appended

        """
        ...
    
    def drop_front(self, cnt: int = ...) -> None:
        """Drop elements from the front.

        Args:
            cnt: the number of elements to drop

        """
        ...
    
    def peek(self, cid: CursorID) -> bool:
        """Check whether a cursor can be advanced without blocking.

        Args:
            cid: the ID of the cursor

        Returns:
            True iff a call to next() will not block due to waiting for a new data item

        """
        ...
    
    def next(self, cid: CursorID) -> None:
        """Advance a cursor by one node.

        Blocks if the cursor is at the end of the queue.

        Args:
            cid: the ID of the cursor

        """
        ...
    


class SharedQueueView(Generic[T]):
    """View of a SharedQueue, i.e., a sub-queue with reduced capabilities."""
    _queue: SharedQueue[T]
    _cid: CursorID
    def __init__(self, queue: SharedQueue[T], cid: CursorID) -> None:
        """Initialize a SharedQueueView object."""
        ...
    
    def __len__(self) -> int:
        """Return the length of the view.

        Returns:
            the number of elements until the end of the view

        """
        ...
    
    def to_list(self) -> list[T]:
        """Return the elements of the view as a list.

        Returns:
             the list of elements until the end of the view

        """
        ...
    
    def __getitem__(self, index: int | slice) -> T | list[T]:
        """Get items from the SharedQueueView.

        Args:
            index: the index of the item to be returned, or the slice of the items to be returned

        Returns:
            the item at the index, or the list of items of the slice

        Raises:
            TypeError: if index is neither int nor slice

        """
        ...
    
    def peek(self) -> bool:
        """Check whether the end of the view can be advanced without blocking due to blocking.

        Returns:
            True iff a call to next() will not block due to waiting for a new data item

        """
        ...
    
    def next(self) -> None:
        """Advance the end of the view by one node.

        Blocks if the view is at the end of the underlying queue.

        """
        ...
    


